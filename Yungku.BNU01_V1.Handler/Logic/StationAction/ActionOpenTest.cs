using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Yungku.BNU01_V1.Handler.Logic.Objects;
using YungkuSystem.Controls;
using YungkuSystem.Statistical;
using YungkuSystem.Structs;
using YungkuSystem.Tester;
using YungkuSystem.TestFlow;

namespace Yungku.BNU01_V1.Handler.Logic.StationAction
{
    public class ActionOpenTest : ActionObject
    {
        // 测试命令对应字典
        private readonly object lockObj = new object();
        private Dictionary<Product, List<ICommand>> testCommands = new Dictionary<Product, List<ICommand>>();
        private HashSet<string> listPrintCmds = new HashSet<string>();
        
        // 已订阅事件的客户端
        private HashSet<IModuleGroup> subscribedClients = new HashSet<IModuleGroup>();

        public override string ObjectClass
        {
            get { return "点亮"; }
        }

        public override bool IsContainner
        {
            get { return false; }
        }
        public override bool IsRunState
        {
            get
            {
                return true;
            }
        }

        [MyDisplayName("点亮次数"), MyCategory("参数"), Description(">1表示开启点亮失败多次点亮")]
        public int OpenCount { get; set; } = 1;


        private string testOpenCommandName = string.Empty;
        /// <summary>
        /// 获取或设置测试命令的名称
        /// </summary>
        [MyDisplayName("点亮命令名称"), MyCategory("测试对象"), Description("请在测试系统配置中查看")]
        public string TestOpenCommandName
        {
            get { return testOpenCommandName; }
            set { testOpenCommandName = value; }
        }
        private string testCloseCommandName = string.Empty;
        /// <summary>
        /// 获取或设置测试命令的名称
        /// </summary>
        [MyDisplayName("关闭命令名称"), MyCategory("测试对象"), Description("请在测试系统配置中查看")]
        public string TestCloseCommandName
        {
            get { return testCloseCommandName; }
            set { testCloseCommandName = value; }
        }

        private CommandType commandType = CommandType.四焦段模式;
        [MyDisplayName("测试协议"), MyCategory("测试对象")]
        public CommandType CommandType
        {
            get { return commandType; }
            set { commandType = value; }
        }

        private YesNo useBarcode = false;
        [MyDisplayName("是否附加二维码测试"), MyCategory("测试对象"), Description("显示在自动页面的状态标签")]
        public YesNo UseBarcode
        {
            get { return useBarcode; }
            set { useBarcode = value; }
        }
        private YesNo useresultcode = false;
        [MyDisplayName("是否附加结果代码"), MyCategory("测试对象"), Description("显示在自动页面的状态标签")]
        public YesNo UseResultcode
        {
            get { return useresultcode; }
            set { useresultcode = value; }
        }

        private int nOpenCount = 0;
        private bool AllIsOk = true;

        /// <summary>
        /// 复制对象成员
        /// </summary>
        /// <param name="dest"></param>
        protected override void CloneMembers(YungkuSystem.Script.Core.Base dest)
        {
            base.CloneMembers(dest);
            ActionOpenTest obj = dest as ActionOpenTest;

        }
        protected override void Execute()
        {
            try
            {
                switch (StateIndex)
                {
                    case ACT_STATE_START:
                        #region    
                        ValidHardware();
                        if (CurrentHeadObject.HasModudeState)
                        {                          
                            nOpenCount = 1;
                            To("发送点亮");
                        }
                        else
                        {
                            To(ACT_STATE_END);
                        }
                     
                        #endregion
                        break;
               
                    case "发送点亮":
                        #region
                        AllIsOk = true;
                        StartTest(testOpenCommandName);
                        listPrintCmds.Clear();
                        To("等待点亮完成");
                    
                        #endregion
                        break;               
                    case "等待点亮完成":                      
                        if (WaitTestDone())
                        {
                            nOpenCount++;
                            To("点亮结果处理");
                        }
                        break;

                    case "点亮结果处理":
                        if(AllIsOk|| nOpenCount > OpenCount)
                        {
                            To(ACT_STATE_END);
                        }
                        else 
                        {
                            To("发送关闭指令");
                        }
                     
                        break;
                    case "发送关闭指令":
                        #region
                        AllIsOk = true;
                        StartTest(testCloseCommandName);
                        listPrintCmds.Clear();
                        To("等待关闭指令完成");

                        #endregion
                        break;
                    case "等待关闭指令完成":
                        if (WaitTestDone())
                        {                          
                            To("打开治具");
                        }
                        break;                  
                    case "打开治具":
                        #region
                    
                            Watcher.StopWatch(StateIndex);
                            Thread.Sleep(1000);
                            To("关闭治具");
                     
                        //else if (Watcher.StartCheckIsTimeout(StateIndex, 10000))
                        //{
                        //    OnAlarm("打开治具超时!");

                        //}
                        #endregion
                        break;

                    case "关闭治具":
                        #region
                        //CurrentHeadObject.SetAllVacuum(true);
                        //CurrentHeadObject.CloseAllJig();
                        //if (CurrentHeadObject.AllJigIsClosed)
                        //{

                        //    CurrentHeadObject.SetAllVacuum(false);
                            Watcher.StopWatch(StateIndex);
                            To("发送点亮");
                        //}
                        //else if (Watcher.StartCheckIsTimeout(StateIndex, 10000))
                        //{
                        //    OnAlarm("关闭治具超时!");

                        //}
                        #endregion
                        break;



                    case ACT_STATE_END:
                        WriteInfo("完成点亮测试");
                        
                        // 清理资源
                        CleanupResources();
                        
                        Finish();
                        break;

                    default:                     
                        State = YungkuSystem.Script.Core.ActionState.Error;
                        CleanupResources(); // 异常状态也要清理
                        To(ACT_STATE_END);
                        break;
                }

            }
            catch (Exception ex)
            {
                WriteInfo(ex.Message, true);
                CleanupResources(); // 发生异常时清理
            }
        }

        /// <summary>
        /// 清理资源
        /// </summary>
        private void CleanupResources()
        {
            try
            {
                // 取消事件订阅
                foreach (var client in subscribedClients)
                {
                    if (client != null)
                    {
                        client.OnReceiveCompleted -= Client_OnReceiveCompleted;
                    }
                }
                subscribedClients.Clear();

                // 清理集合
                lock (lockObj)
                {
                    testCommands.Clear();
                    listPrintCmds.Clear();
                }
            }
            catch (Exception ex)
            {
                WriteInfo($"清理资源时发生异常: {ex.Message}", true);
            }
        }

        /// <summary>
        /// 开始测试
        /// </summary>
        private void StartTest(string cmdName)
        {
            //获取当前站位和对应转盘上的测试头
            Station st = Station.Station;
            Head hd = st.Turntable.GetHeadByStation(st);
            //站位或测试头有一个被关闭时都不应该继续执行
            if (!st.Enabled || !hd.Enabled)
                return;
            #region
            //遍历测试头中的站位对象
            //foreach (Jig jig in hd.TestItems)
            //{
            //    if (jig.Enabled)
            //    {
            //        foreach (Product product in jig.TestItems)
            //        {
            //            //找到产品在测试头上的索引
            //            int pIndex = hd.ProductIndexOf(product);
            //            if (product.Enabled)
            //            {
            //                ProductObject po = product.BindingObject as ProductObject;
            //                foreach (Module module in product.TestItems)
            //                {
            //                    if (module.Enabled)
            //                    {
            //                        try
            //                        {
            //                            if (CanContinue(product))
            //                                Test(cmdName,product, module);
            //                        }
            //                        catch (Exception ex)
            //                        {
            //                            WriteInfo(po.Name + "测试时发生异常！");
            //                            WriteInfo(ex.ToString());
            //                            OnAlarm(ex.Message + ":" + po.Name + "测试时发生异常！");
            //                            product.Result = TestResult.Fail;
            //                            product.ResultCode = "Error";
            //                        }
            //                    }
            //                }
            //            }
            //        }
            //    }
            //}
            #endregion
            //使用索引避免重复查找，提前过滤
            
            var enabledJigs = hd.TestItems.Where(j => j.Enabled).ToList();
            foreach (Jig jig in enabledJigs)
            {
                var enabledProducts = jig.TestItems.Where(p => p.Enabled).ToList();
                foreach (Product product in enabledProducts)
                {
                    ProductObject po = product.BindingObject as ProductObject;
                    if (po == null)
                    {
                        WriteInfo(string.Format("产品 {0} 的 BindingObject 为空，跳过测试", product.Name));
                        continue;
                    }

                    var enabledModules = product.TestItems.Where(m => m.Enabled).ToList();
                    foreach (Module module in enabledModules)
                    {
                        try
                        {
                            if (CanContinue(product))
                                Test(cmdName, product, module);
                        }
                        catch (Exception ex)
                        {
                            HandleTestException(po, ex, product);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// 处理测试异常
        /// </summary>
        private void HandleTestException(ProductObject po, Exception ex, Product product)
        {
            WriteInfo(po.Name + "测试时发生异常！");
            WriteInfo(ex.ToString());
            OnAlarm(ex.Message + ":" + po.Name + "测试时发生异常！");
            product.Result = TestResult.Fail;
            product.ResultCode = "Error";
        }

        /// <summary>
        /// 判断是否可以继续测试产品
        /// </summary>
        /// <param name="product"></param>
        /// <returns></returns>
        private bool CanContinue(Product product)
        {
            // 空状态不允许测试
            if (product.Result == TestResult.Empty)
                return false;
            
            // 必须执行模式：任何非空状态都继续
            if (this.MustExecute)
                return true;
            
            // 正常模式：只有Pass才继续
            return product.Result == TestResult.Pass;
        }

        /// <summary>
        /// 等待测试完成
        /// </summary>
        /// <returns></returns>
        private bool WaitTestDone()
        {
            if (testCommands.Count == 0)
            {
                WriteInfo("警告：没有待处理的测试命令");
                return true;
            }

            IStatistical statis = MyApp.GetInstance().Statistical;

            // 复制字典以避免遍历时被修改
            Dictionary<Product, List<ICommand>> commandsCopy;
            lock (lockObj)
            {
                commandsCopy = new Dictionary<Product, List<ICommand>>(testCommands);
            }

            foreach (Product product in commandsCopy.Keys)
            {
                IModuleGroup client = GetClient(product);
                if (client == null)
                {
                    WriteInfo($"产品 {product.Name} 的客户端为空,跳过");
                    continue;
                }
                foreach (ICommand cmd in commandsCopy[product])
                {
                    ICommand doneCmd = client.GetDone(cmd, true);
                    if (doneCmd != null)
                    {
                        switch (doneCmd.CmdState)
                        {
                            case CmdState.AlreadySent:
                            case CmdState.Error:
                            case CmdState.Ready:
                                product.Result = TestResult.Error;
                                break;

                            case CmdState.Timeout:
                                product.Result = TestResult.Timeout;
                                product.ResultCode = "-1";
                                break;

                            case CmdState.OK:

                                if (MustExecute && product.IsFail)//必须执行时，产品已经Fail，则不改变状态
                                {
                                    //必须执行时，产品已经Fail，则不改变状态
                                    //且当前不是二次点亮前的关闭指令
                                }
                                else
                                {

                                    //此处不再使用原系统的Result判断Pass、Fail，而直接用ResultCode通过统计系统判断
                                    if (statis.PassCodes.Contains(doneCmd.ResultCode))
                                    {
                                        product.Result = TestResult.Pass;//_LJL1
                                    }
                                    else
                                    {
                                        product.Result = TestResult.Fail;
                                        product.ResultCode = doneCmd.ResultCode;
                                    }


                                }
                                break;
                        }
                        //string PrintID = product.Name + "_" + doneCmd.Id.ToString();//保证每条收到的指令只打印一次
                        // 使用 StringBuilder 或插值
                        string PrintID = $"{product.Name}_{doneCmd.Id}";
                        // 在 WaitTestDone 中使用
                        lock (lockObj)
                        {
                            if (listPrintCmds.Add(PrintID)) // Add 返回 true 表示成功添加（之前不存在）
                            {
                                string strResult = doneCmd.ResultCode;
                                Head hd = Station.Station.Turntable.GetHeadByStation(Station.Station);
                                string msg = string.Format("测试头:{0},治具:{1},模组:{2},收到回复指令{3},指令当前状态:{4},指令运行结果:{5},第{6}次点亮",
                                                 hd.Name, product.Jig.Name, product.Name, doneCmd.Name, doneCmd.CmdState.ToString(), strResult, nOpenCount);
                                WriteInfo(msg);
                            }
                        }

                        if (product.IsFail)
                            AllIsOk = false;
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            lock (lockObj)
            {
                testCommands.Clear();
                listPrintCmds.Clear();
            }
            return true;
        }


        /// <summary>
        /// 获取客户端
        /// </summary>
        /// <param name="product"></param>
        /// <returns></returns>
        private IModuleGroup GetClient(Product product)
        {
            try
            {
                //ProductObject obj = (product.BindingObject as ProductObject);
                //IModuleGroup client;
                //client = (product.BindingObject as ProductObject).TestClient;
                //if (client == null)
                //    throw new NullReferenceException("未能获取到测试名为：" + product.Name + "的客户端，请配置！");
                //return client;
                return null;
            }
            catch (Exception ex)
            {
                WriteInfo(ex.Message, true);
                return null;
            }
        }

        private void Test(string cmdName, Product product, Module module)
        {
            IModuleGroup client = GetClient(product);
            ITestSystem testSystem = MyApp.GetInstance().TestSystem;
            
            if (client == null)
            {
                WriteInfo("客户端为空");
                return;
            }
            
            // 只订阅一次
            if (!subscribedClients.Contains(client))
            {
                client.OnReceiveCompleted += Client_OnReceiveCompleted;
                subscribedClients.Add(client);
            }
            
            Connect(client);
            client.ClearAllCommand();
            
            //获取当前模块索引
            int mIndex = product.TestItems.IndexOf(module);
            ProductObject po = product.BindingObject as ProductObject;
            if (mIndex >= 0)
            {
                if (module.Enabled)
                {
                    product.Result = TestResult.Pass;
                    product.ResultCode = MyApp.GetInstance().Statistical.AnyPassCode;

                    ICommand cmd = testSystem.CreateCommand(cmdName, CommandType);
                    if (this.useBarcode)
                    {
                        IParameter param = cmd as IParameter;
                        param.ClearInputParameters();
                        param.AddInputParameter(product.BarCodeString);
                        WriteInfo("添加摄像头二维码参数：" + product.BarCodeString);
                    }
                    else if (useresultcode)
                    {
                        IParameter param = cmd as IParameter;
                        param.ClearInputParameters();
                        param.AddInputParameter((po.Owner as Product).ResultCode.ToString());
                        WriteInfo("添加结果代码：" + (po.Owner as Product).ResultCode.ToString());
                    }
                    client.ClientSend(cmd, mIndex);

                    Head hd = Station.Station.Turntable.GetHeadByStation(Station.Station);
                    string msg = string.Format("测试头:{0},治具:{1},模组:{2},ModuleIndex:{3},发送指令{4}",
                                      hd.Name, product.Jig.Name, product.Name, mIndex.ToString(), cmd.Name);
                    WriteInfo(msg);
                    AddToList(product, cmd);
                }
            }
        }

        private void Client_OnReceiveCompleted(object sender, SocketDatagramReceivedEventArgs<Dictionary<string, string>> e)
        {
            Dictionary<string, string> data = e.Datagram;
            foreach (string name in data.Keys)
            {
                WriteInfo(string.Format("{0}发送消息【{1】至【{2}】", e.Socket != null ? e.Socket.RemoteEndPoint.ToString() : "", data[name], name));
            }

        }



        /// <summary>
        /// 添加产品
        /// </summary>
        /// <param name="product"></param>
        /// <param name="cmd"></param>
        private void AddToList(Product product, ICommand cmd)
        {
            lock (lockObj)
            {
                if (!testCommands.ContainsKey(product))
                    testCommands.Add(product, new List<ICommand>());
                if (!testCommands[product].Contains(cmd))
                    testCommands[product].Add(cmd);
            }
        }

        /// <summary>
        /// 测试程序连接
        /// </summary>
        /// <param name="client"></param>
        private void Connect(IModuleGroup client)
        {
            // 已连接则直接返回
            if (client.RealConnectionState == YungkuSystem.Tester.ConnectionState.Connected)
                return;

            const int maxRetry = 3;
            const int retryDelayMs = 500;
            
            for (int attempt = 1; attempt <= maxRetry; attempt++)
            {
                try
                {
                    WriteInfo(string.Format("尝试连接测试程序(第{0}/{1}次)...", attempt, maxRetry));
                    
                    client.Uinit();
                    Thread.Sleep(100);
                    client.Init();
                    Thread.Sleep(retryDelayMs);
                    
                    // 验证连接状态
                    if (client.RealConnectionState == YungkuSystem.Tester.ConnectionState.Connected)
                    {
                        WriteInfo("测试程序连接成功");
                        return;
                    }
                    
                    WriteInfo(string.Format("连接失败，状态: {0}", client.RealConnectionState));
                }
                catch (System.Net.Sockets.SocketException ex)
                {
                    WriteInfo(string.Format("Socket连接失败(第{0}次): {1}", attempt, ex.Message));
                }
                catch (Exception ex)
                {
                    WriteInfo(string.Format("连接异常(第{0}次): {1}", attempt, ex.Message));
                }
                
                // 最后一次尝试失败后不再等待
                if (attempt < maxRetry)
                {
                    Thread.Sleep(retryDelayMs);
                }
            }
            
            // 所有重试失败
            string errorMsg = string.Format("测试程序连接失败，已重试{0}次", maxRetry);
            WriteInfo(errorMsg);
            throw new TimeoutException(errorMsg);
        }
    }
}
